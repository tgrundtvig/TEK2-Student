# Pre-class Reading: Maven and CI/CD with GitHub Actions

**Estimated reading time: 45-60 minutes**

This week we solve a new problem: manual, error-prone deployments. By the end of this week, your code will automatically build and test itself every time you push to GitHub.

---

## The Manual Deployment Problem

Remember building and pushing Docker images in Week 2? Every time you made changes, you had to:

1. Edit your code
2. Run `docker build` manually
3. Test it (hopefully!)
4. Push to Docker Hub manually
5. Hope you didn't forget any steps

Now imagine working on a team. What happens when:

> "I pushed my changes but forgot to run the tests."

> "I built the image from the wrong branch."

> "It works on my machine... but I pushed it to production without testing."

These aren't hypothetical - they're daily occurrences in software development. The solution? **Automation.**

---

## What is CI/CD?

**CI** stands for **Continuous Integration** - automatically building and testing code every time someone pushes changes.

**CD** stands for **Continuous Delivery** or **Continuous Deployment** - automatically deploying tested code to production.

Together, they form a **pipeline** that catches errors early and automates repetitive tasks.

```
Developer pushes code
        │
        ▼
┌──────────────────────────────────────────────────────────────┐
│                        CI/CD Pipeline                         │
│                                                               │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────────┐   │
│  │   Trigger   │───▶│    Build    │───▶│      Test       │   │
│  │  (on push)  │    │  (compile)  │    │  (run tests)    │   │
│  └─────────────┘    └─────────────┘    └────────┬────────┘   │
│                                                  │            │
│                                   ┌──────────────▼─────────┐  │
│                                   │  If tests pass:        │  │
│                                   │  Deploy / Push image   │  │
│                                   └────────────────────────┘  │
└──────────────────────────────────────────────────────────────┘
        │
        ▼
   Production
```

### The Key Benefits

| Without CI/CD | With CI/CD |
|---------------|------------|
| Manual builds | Automatic builds on every push |
| "Forgot to test" | Tests run automatically |
| "Works on my machine" | Builds in consistent environment |
| Errors found late | Errors caught immediately |
| Stressful deployments | Confident, repeatable deployments |

---

## The Java Build Problem

Before we set up CI/CD, we need a build tool. For Java projects, that's **Maven**.

### Why Do Java Projects Need a Build Tool?

Java projects have unique challenges:

1. **Compilation**: Java source files (`.java`) must be compiled to bytecode (`.class`)
2. **Dependencies**: Projects use external libraries (JARs) - sometimes dozens of them
3. **Testing**: Tests need to be compiled and run separately from main code
4. **Packaging**: Everything must be bundled into a single JAR or WAR file

Imagine doing this manually:

```bash
# Download 15 different JAR files...
# Put them in the right place...
# Compile your code with the right classpath...
javac -cp lib/gson-2.10.jar:lib/junit-4.13.jar:lib/... src/main/java/com/example/*.java
# Run tests...
# Package into a JAR...
# Hope you got the versions right...
```

This is tedious and error-prone. Different developers might use different versions, or forget steps.

### Maven to the Rescue

**Maven** standardizes Java project builds:

- **One command** to compile, test, and package: `mvn clean package`
- **Automatic dependency downloads** from Maven Central (like npm for Java)
- **Consistent project structure** everyone follows
- **Reproducible builds** - same input = same output

---

## Maven Project Structure

Maven expects a specific folder structure:

```
my-app/
├── pom.xml                        ← Project configuration file
├── src/
│   ├── main/
│   │   └── java/                  ← Your application code
│   │       └── com/
│   │           └── example/
│   │               └── App.java
│   └── test/
│       └── java/                  ← Your test code
│           └── com/
│               └── example/
│                   └── AppTest.java
└── target/                        ← Build output (generated)
    ├── classes/                   ← Compiled .class files
    └── my-app-1.0.jar             ← Packaged application
```

Key points:
- **src/main/java**: Your application code
- **src/test/java**: Your test code (mirrors the main structure)
- **target/**: Generated by Maven (don't commit this to git!)
- **pom.xml**: The heart of Maven - defines everything

---

## The POM File

**POM** stands for **Project Object Model**. The `pom.xml` file defines:

- Project identity (name, version)
- Dependencies (external libraries)
- Build configuration (plugins, Java version)

Here's a minimal example:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <!-- Project identity -->
    <groupId>com.example</groupId>      <!-- Organization/company -->
    <artifactId>my-app</artifactId>     <!-- Project name -->
    <version>1.0-SNAPSHOT</version>     <!-- Version -->
    <packaging>jar</packaging>          <!-- Output type -->

    <!-- Build settings -->
    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
    </properties>

    <!-- External libraries -->
    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.13.2</version>
            <scope>test</scope>         <!-- Only used for tests -->
        </dependency>
    </dependencies>
</project>
```

When Maven sees this file, it knows:
- This is a Java 17 project
- It needs JUnit 4.13.2 for testing
- It should produce a JAR file named `my-app-1.0-SNAPSHOT.jar`

---

## Maven Build Lifecycle

Maven has a defined **build lifecycle** with phases:

```
┌───────────────────────────────────────────────────────────────┐
│                    Maven Build Lifecycle                       │
│                                                                │
│  validate ──▶ compile ──▶ test ──▶ package ──▶ install ──▶ deploy
│     │           │          │         │           │          │
│     │           │          │         │           │          │
│  Validate    Compile    Run      Create      Install     Deploy
│  pom.xml     source     unit     JAR/WAR    to local    to remote
│              code       tests               Maven repo   server
└───────────────────────────────────────────────────────────────┘
```

When you run a phase, all earlier phases run first:

| Command | What happens |
|---------|--------------|
| `mvn compile` | Compiles source code |
| `mvn test` | Compiles + runs tests |
| `mvn package` | Compiles + tests + creates JAR |
| `mvn clean` | Deletes the target/ directory |
| `mvn clean package` | Clean start + full build |

The most common command is `mvn clean package` - start fresh and build everything.

---

## Maven + Docker

Here's something powerful: you don't need to install Maven on your computer. You can run it in Docker!

```
┌─────────────────────────────────────────────────────────────┐
│                    Your Computer                             │
│                                                              │
│  ┌───────────────────────────────────────────────────────┐  │
│  │              maven:3.9 Docker Container               │  │
│  │                                                       │  │
│  │   Maven + Java pre-installed                          │  │
│  │                                                       │  │
│  │   ┌─────────────────────────────────────────────┐    │  │
│  │   │  Your project files (bind mount)            │    │  │
│  │   │  pom.xml, src/, etc.                        │◄───────── Mounted from
│  │   └─────────────────────────────────────────────┘    │  │  your computer
│  │                                                       │  │
│  │   mvn clean package                                   │  │
│  │         │                                             │  │
│  │         ▼                                             │  │
│  │   target/my-app.jar (written back to your files)     │  │
│  └───────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

The command:
```bash
docker run --rm -v $(pwd):/app -w /app maven:3.9-eclipse-temurin-17 mvn clean package
```

Breaking it down:
- `--rm` - remove container after it exits
- `-v $(pwd):/app` - mount current directory into container
- `-w /app` - set working directory inside container
- `maven:3.9-eclipse-temurin-17` - Maven 3.9 with Java 17
- `mvn clean package` - the Maven command

This approach:
- **No local Java/Maven installation** needed
- **Consistent environment** across all developers
- **Same approach CI systems use** (preview of GitHub Actions!)

---

## GitHub Actions

Now let's automate everything with **GitHub Actions** - a CI/CD platform built into GitHub.

### How It Works

```
┌────────────────────────────────────────────────────────────────┐
│                     Your GitHub Repository                      │
│                                                                 │
│  .github/                                                       │
│  └── workflows/                                                 │
│      └── ci.yml  ◄─── Workflow definition file                  │
│                                                                 │
│  When you push code:                                            │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │              GitHub Actions Runner                         │ │
│  │         (Virtual machine hosted by GitHub)                 │ │
│  │                                                            │ │
│  │  1. Check out your code                                    │ │
│  │  2. Set up Java 17                                         │ │
│  │  3. Run: mvn clean package                                 │ │
│  │  4. Run: mvn test                                          │ │
│  │  5. Report success or failure                              │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                                 │
│  Result: Green checkmark ✓ or Red X ✗ next to your commit      │
└────────────────────────────────────────────────────────────────┘
```

Key concepts:

| Term | Meaning |
|------|---------|
| **Workflow** | An automated process defined in a YAML file |
| **Trigger** | What starts the workflow (push, pull request, schedule) |
| **Job** | A set of steps that run on the same runner |
| **Step** | A single task (run a command, use an action) |
| **Runner** | The virtual machine that executes your workflow |
| **Action** | A reusable unit of code (like `actions/checkout`) |

---

## Anatomy of a Workflow File

Workflow files live in `.github/workflows/` and use YAML syntax:

```yaml
# .github/workflows/ci.yml

name: Java CI                     # Name shown in GitHub UI

on:                               # Triggers - when to run
  push:
    branches: [ main ]            # Run on push to main
  pull_request:
    branches: [ main ]            # Run on PR to main

jobs:                             # What to do
  build:                          # Job name (can be anything)
    runs-on: ubuntu-latest        # Runner type (Linux VM)

    steps:                        # Sequential steps
      - name: Check out code
        uses: actions/checkout@v4 # Use a pre-built action

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Build with Maven
        run: mvn clean package    # Run a shell command
```

### Understanding Each Part

**Triggers (`on:`)**
```yaml
on:
  push:
    branches: [ main ]     # When code is pushed to main
  pull_request:
    branches: [ main ]     # When a PR targets main
```

**Jobs**
```yaml
jobs:
  build:                   # This job is called "build"
    runs-on: ubuntu-latest # Run on Ubuntu Linux
```

**Steps with Actions**
```yaml
steps:
  - uses: actions/checkout@v4  # Use the checkout action v4
```

Actions are reusable components. `actions/checkout` is maintained by GitHub and checks out your repository code.

**Steps with Commands**
```yaml
steps:
  - name: Build with Maven
    run: mvn clean package     # Run this shell command
```

---

## Putting It All Together

Here's the complete picture:

```
                    LOCAL                                    GITHUB
┌────────────────────────────────┐      ┌─────────────────────────────────────┐
│                                │      │                                     │
│  1. Write Java code            │      │  .github/workflows/ci.yml           │
│     src/main/java/...          │      │                                     │
│                                │      │  Defines:                           │
│  2. Write tests                │      │  - When to run (on: push)           │
│     src/test/java/...          │      │  - What to do (mvn clean package)   │
│                                │      │                                     │
│  3. Test locally (optional)    │      └─────────────────────────────────────┘
│     docker run ... mvn test    │                     │
│                                │                     │
│  4. Commit and push            │                     ▼
│     git add . && git commit    │      ┌─────────────────────────────────────┐
│     git push                   │──────│  GitHub detects push + workflow     │
│                                │      │                                     │
└────────────────────────────────┘      │  GitHub Actions Runner:             │
                                        │  1. Checkout code                   │
                                        │  2. Setup Java                      │
                                        │  3. mvn clean package               │
                                        │  4. mvn test                        │
                                        │                                     │
                                        │  Result: ✓ Pass or ✗ Fail           │
                                        └─────────────────────────────────────┘
                                                       │
                                                       ▼
                                        ┌─────────────────────────────────────┐
                                        │  You see the result on GitHub:      │
                                        │                                     │
                                        │  commit abc123 ✓                    │
                                        │  "Add new feature"                  │
                                        │                                     │
                                        │  Or if tests fail:                  │
                                        │                                     │
                                        │  commit def456 ✗                    │
                                        │  "Oops, broke something"            │
                                        └─────────────────────────────────────┘
```

---

## Why This Matters

With CI/CD set up:

1. **Every push is tested** - No more "forgot to test"
2. **Broken code is caught immediately** - Red X appears within minutes
3. **Team confidence increases** - If it's green, it works
4. **Deployment becomes boring** - Automated = reliable

This is the foundation of modern software development. Companies use CI/CD for everything from simple websites to mission-critical systems.

---

## Self-Check Questions

Before moving to the exercises, make sure you can answer these:

1. What does CI stand for, and what problem does it solve?

2. What file defines a Maven project's configuration, dependencies, and build settings?

3. What Maven command compiles code, runs tests, and creates a JAR file?

4. Where do GitHub Actions workflow files live in a repository?

5. What triggers a GitHub Actions workflow to run?

<details>
<summary>Click to reveal answers</summary>

1. **Continuous Integration** - It solves the problem of code integration by automatically building and testing code every time changes are pushed, catching errors early instead of finding them later.

2. **pom.xml** (Project Object Model) - This XML file defines the project's identity (groupId, artifactId, version), dependencies, plugins, and build configuration.

3. `mvn clean package` - "clean" removes old build artifacts, then the package phase compiles, tests, and creates the JAR file.

4. In the `.github/workflows/` directory in your repository. Files are typically named something like `ci.yml` or `build.yml`.

5. Triggers defined in the `on:` section of the workflow file - commonly `push` (when code is pushed), `pull_request` (when a PR is opened/updated), or `schedule` (cron-based timing).

</details>

---

## Further Reading (Optional)

If you want to learn more:

- [Maven in 5 Minutes](https://maven.apache.org/guides/getting-started/maven-in-five-minutes.html) - Official quick start
- [GitHub Actions Quickstart](https://docs.github.com/en/actions/quickstart) - Official tutorial
- [Understanding GitHub Actions](https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions) - Deeper concepts

---

**Next step**: Continue to [exercises.md](exercises.md) to build a Java project and set up your first CI pipeline.
